from schema import Schema, SchemaError, Regex, And, Or, Optional, Useimport yamlimport logginglogger = logging.getLogger('DT_ernesto')FILE_TYPES = [    'battery_options',    'model']schemas = {}string_pattern = Regex(r'^[a-zA-Z0-9_. ]+$',                       error="Error in string '{}': it can only have a-z, A-Z, 0-9, and _.")path_pattern = Regex(r'^[a-zA-Z0-9_./]+$',                     error="Error in path '{}': it can only have a-z, A-Z, 0-9, ., / and _.")class_pattern = Regex(r'^[a-zA-Z0-9]+$',                      error="Error in class name '{}': it can only have a-z, A-Z and 0-9.")var_pattern = Regex(r'^[a-z_]+$',                    error="Error in variable '{}': it can only have a-z and _.")label_pattern = Regex(r'^[a-zA-Z0-9_\[\]() ]+$',                      error="Error in label '{}': it can only have a-z, A-Z, [,], and _.")unit_pattern = Regex(r'^[a-zA-Z_]+$',                     error="Error in unit identifier '{}': it can only have a-z, A-Z.")# ---------------# Battery schema# ---------------battery_param = Schema(    {        "var": And(str, var_pattern, Use(str.lower)),        "value": Or(float, int),        "unit": Or(And(str, unit_pattern), None)    })bound_param = Schema(    {        "low": Or(float, And(int, Use(float))),        "high": Or(float, And(int, Use(float)))    })battery_options = Schema(    {        "sign_convention": Or('active', 'passive'),        "params": {            "nominal_capacity": battery_param,            "v_max": battery_param,            "v_min": battery_param,            "temp_ambient": battery_param,            Optional("nominal_voltage"): battery_param,            Optional("nominal_dod"): battery_param,            Optional("nominal_lifetime"): battery_param,            Optional("nominal_dod"): battery_param,            Optional("nominal_lifetime"): battery_param,            Optional("polarization_constant"): battery_param,            Optional("nominal_cost"): battery_param        },        "bounds":            {                'voltage': bound_param,                'current': bound_param,                'power': bound_param,                'temperature': bound_param,                Optional('temp_ambient'): bound_param,                'soc': bound_param,                'soh': bound_param,            },        "init":            {                'voltage': Or(float, And(int, Use(float))),                'current': Or(float, And(int, Use(float))),                'power': Or(float, And(int, Use(float))),                'temperature': Or(float, And(int, Use(float))),                Optional('temp_ambient'): Or(float, And(int, Use(float))),                'soc': Or(float, And(int, Use(float))),                'soh': Or(float, And(int, Use(float))),            },        Optional("reset_soc_every"): Or(int, None)    })battery = Schema({"battery": battery_options})# ---------------------# ECM component schema# ---------------------single_comp_hardcoded_lookup = Schema(    {        "selected_type": Or('scalar', 'lookup'),        Optional("scalar"): Or(float, And(int, Use(float))),        Optional("lookup"): {            "inputs": {                Optional('temp'): [Or(float, int)],                Optional('soc'): [And(Or(float, And(int, Use(float))), lambda n: 0 <= n <= 1)],                Optional('soh'): [And(Or(float, And(int, Use(float))), lambda n: 0 <= n <= 1)],            },            "output": [Or(float, And(int, Use(float)))]        }    },)single_comp_csv_lookup = Schema(    {        "selected_type": Or('scalar', 'lookup'),        Optional("scalar"): Or(float, And(int, Use(float))),        Optional("lookup"): {            "table": And(str, path_pattern),            "inputs": [{                "var": And(str, var_pattern),                "label": And(str, label_pattern),                "unit": Or(And(str, unit_pattern), None)            }],            "output": {                "var": And(str, var_pattern),                "label": And(str, label_pattern),                "unit": Or(And(str, unit_pattern), None)            }        }    },)# -----------------------# Battery modules schema# -----------------------thevenin = Schema(    {   # Thevenin        "r0": Or(single_comp_csv_lookup, single_comp_hardcoded_lookup),        "r1": Or(single_comp_csv_lookup, single_comp_hardcoded_lookup),        "c": Or(single_comp_csv_lookup, single_comp_hardcoded_lookup),        "v_ocv": Or(single_comp_csv_lookup, single_comp_hardcoded_lookup)    })rc_thermal = Schema(    {  # RC_thermal        "r_term": Or(single_comp_csv_lookup, single_comp_hardcoded_lookup),        "c_term": Or(single_comp_csv_lookup, single_comp_hardcoded_lookup),    })r2c_thermal = Schema(    {   # R2C_thermal        Optional("lambda"): single_comp_hardcoded_lookup,        Optional("length"): single_comp_hardcoded_lookup,        Optional("area_int"): single_comp_hardcoded_lookup,        Optional("area_surf"): single_comp_hardcoded_lookup,        Optional("h"): single_comp_hardcoded_lookup,        Optional("mass"): single_comp_hardcoded_lookup,        Optional("cp"): single_comp_hardcoded_lookup,        "c_term": single_comp_hardcoded_lookup,        "r_cond": single_comp_hardcoded_lookup,        "r_conv": single_comp_hardcoded_lookup,        "dv_dT": single_comp_hardcoded_lookup    })mlp_thermal = Schema(    {  # MLP_thermal        "input_size": And(int),        "hidden_size": And(int),        "output_size": And(int),        "model_state": And(str, path_pattern),        "scaler": And(str, path_pattern),        "cuda": Or(False, True)    })bolun = Schema(    {  # Bolun        "SEI": {            "alpha_sei": Or(float, And(int, Use(float))),            "beta_sei": Or(float, And(int, Use(float))),        },        "stress_factors": {            "calendar": [And(str, var_pattern)],            "cyclic": [And(str, var_pattern)],        },        "cycle_counting_mode": Or('rainflow', 'streamflow', 'fastflow'),        #"compute_every": And(int)    },)stress_model_schema = Schema(    {        "time": {            "k_t": Or(float, And(int, Use(float))),        },        "soc": {            "k_soc":Or(float, And(int, Use(float))),            "soc_ref": Or(float, And(int, Use(float)))        },        "temperature": {            "k_temp": Or(float, And(int, Use(float))),            "temp_ref": Or(float, And(int, Use(float)))        },        "dod_bolun": {            "k_delta1": Or(float, And(int, Use(float))),            "k_delta2": Or(float, And(int, Use(float))),            "k_delta3": Or(float, And(int, Use(float)))        },        Optional("dod_quadratic"): Or(float, And(int, Use(float))),        Optional("dod_exponential"): Or(float, And(int, Use(float))),    })model_schema = Schema(    {        "type": And(str, var_pattern),        "class_name": And(str, class_pattern),        Optional("use_fading"): Or(True, False),        Optional('alpha_fading'): Or(float, And(int, Use(float))),        Optional('beta_fading'): Or(float, And(int, Use(float))),        Optional("components"): Or(thevenin, rc_thermal, r2c_thermal, mlp_thermal, bolun),        Optional("stress_models"): stress_model_schema    })schemas['battery_options'] = batteryschemas['model'] = model_schemadef _check_schema(yaml_dict: dict, schema_type: str):    """            Args:        yaml_dict (dict): _description_        schema_type (str): _description_    """    try:        schemas[schema_type].validate(yaml_dict)    except SchemaError as se:        raise sedef read_yaml(yaml_file: str, yaml_type: str, bypass_check: bool = False):    """    """    if bypass_check:        logger.info("YAML file will be read without schema validation")    if yaml_type not in FILE_TYPES and not bypass_check:        raise KeyError("The schema type of file {} is not existing!".format(yaml_file))    with open(yaml_file, 'r') as fin:        params = yaml.safe_load(fin)    if not bypass_check:        try:            _check_schema(params, yaml_type)        except SchemaError as se:            logger.error("Error within the yaml file '{}': {}".format(yaml_file, se.args[0]))            raise se    return params